//===================================================================================================================== 
//
// litegrid.cpp : Implementation of class CLiteGrid, a version of the "MFC Grid Control" that provides internal support 
//                for editing individual cells of the grid in its "virtual mode".
//
// AUTHOR:  saruffner
//
// DESCRIPTION:
// Chris Maunder's "MFC Grid Control", CGridCtrl (CREDITS), is a versatile spreadsheet-like control that can be easily 
// tailored for a variety of uses.  In its default form, a "grid cell object" is created for every cell in the grid -- 
// allowing the developer to customize the behavior of and user interaction with each cell.  For larger grids, or for 
// any grid with cells displaying similar kinds of data, this could be a rather wasteful implementation.  As an 
// alternative, CGridCtrl provides a "virtual" mode, in which no grid cell objects are created; instead, the grid 
// queries its parent for cell display information (text contents, cell bkg color, etc) as needed.  However, the grid 
// is read-only in this mode, so the parent window (usually a dialog or form view) must provide some mechanism for 
// editing grid contents.
//
// CLiteGrid is a derivative of CGridCtrl that offers some built-in editing functionality for the grid in virtual mode. 
// It uses four different "inplace" editing controls to modify four kinds of data that might appear in grid cells:
//
//    1) CInPlaceTextEdit -- This inplace edit box is used to edit general one-line text strings.  It is similar to 
//       Maunder's CInPlaceEdit control (CREDITS), but it is not specifically tied to the CGridCtrl and it is designed 
//       for reuse in the same manner as the other inplace controls described here.
//    2) CInPlaceNumEdit -- An inplace edit box specialized for the display and modification of numerical values IAW 
//       a restricted format.
//    3) CInPlaceCombo -- An inplace combo box (CBS_DROPDOWNLIST style only) for display and modification of multiple-
//       choice parameters.
//    4) CInPlaceTree -- An inplace tree ctrl for choosing an item from a hierarchical tree.
//
// These controls are "inplace" in the sense that they appear on top of the grid control on demand -- usually over the 
// grid cell whose contents the user wishes to change --, and are extinquished as soon as they lose the input focus or 
// if the user terminates the inplace editor operation by hitting an "exit character" key such as "Enter", "ESC", 
// "TAB"; or "CTRL" in combination with any of the following navigational keys:  "Home", "End", "PgUp", "PgDn", or one 
// of the arrow keys.  [The CTRL key is required with the navigational keys because each inplace control uses these 
// keys to navigate within the control itself!]  Hitting the ESC key will cancel the inplace operation, while hitting 
// any other key or changing the keyboard focus with the mouse will confirm the changes made with the inplace control.
//
// The parent window must still provide the cell display information as the grid demands it.  In addition, it must 
// install several callback functions required to edit and validate cell contents.  CLiteGrid can then handle the 
// "mechanics" of editing grid cell contents on its own, removing that burden from the parent window class.
//
// In addition to the inplace controls, CLiteGrid provides a mechanism to update a cell's contents merely by clicking 
// on the cell with the right mouse button.  The grid "edit" callback function will determine the effect, if any, of a 
// right-click on the parameter contained in the cell, with or without the SHIFT key depressed.   Typical usage:  
// incrementing or decrementing the current selection for a multiple-choice parameter, or incrementing/decrementing a 
// numeric parameter by a fixed quantity....  We use MFC message reflection to handle the NM_RCLICK notifications 
// generated by the CGridCtrl implementation.  However, the parent window will still have an opportunity to handle this 
// notification if the callback did not modify the cell's contents in response to the mouse click, if the callback is 
// not defined, or the grid is not in virtual mode.  See OnRightClick().
// 
// CLiteGrid implements the new functionality by overriding certain CGridCtrl methods dedicated to grid editing.  The 
// key override is OnEditCell(), which is invoked by the grid control to initiate an edit operation by a whole host of 
// mechanisms:  double-clicking on a cell, hitting the F2 key with the focus on a valid grid cell, etc. NOTE that the 
// grid MUST be in virtual mode and the grid edit callbacks MUST be installed to access this functionality.  If these 
// requirements are not satisfied, CLiteGrid behaves just like its base class!
// 
// ==> Usage.
// Whenever the CLiteGrid is created, ensure that it is placed in virtual mode and that the following callback 
// functions are installed before making the grid control visible:
// 
//    GRIDCALLBACK GridDisplayCallback( GV_DISPINFO* gvdi, LPARAM lParam ) ==> This callback is invoked in virtual mode 
//       whenever the grid requires display information for a grid cell.  See CGridCtrl's documentation for details.
//       The parent window can either supply this callback or respond to the grid's GVN_GETDISPINFO notification.
//
//    EDITCB GridEditCallback( EDITINFO* pEI, LPARAM lParam ) ==> This callback is invoked by CLiteGrid when it 
//       prepares to edit the current contents of a grid cell using an inplace editor tool.  The row and col coords of 
//       the cell to be edited are initialized in the EDITINFO structure, and the callback function must fill in the 
//       appropriate fields of that structure IAW the kind of data that is represented by that cell.  Eg, if the cell 
//       displays a multiple-choice parameter, the callback would fill a CStringArray wit the list of possible choices 
//       for that parameter (in order), along with the zero-based index indicating the current selection.  See 
//       definition of the EDITINFO structure for details.  Of course, if the callback tags the cell as read-only (such 
//       as a row or column header cell), CLiteGrid will not initiate an inplace operation.
//
//       This callback is also invoked whenever the user right-clicks (NM_RCLICK) a grid cell.  In this case, the 
//       callback must indicate whether the action has changed the contents of the cell, in which case CLiteGrid will 
//       redraw the cell to reflect the change.  By convention, a right click without the SHIFT key depressed should be 
//       interpreted as an "incrementing" action, while the right click accompanied by the SHIFT key should be taken as 
//       a "decrementing" action.  A single left-click must not affect cell contents, since that would confuse the user 
//       that is trying to initiate an inplace edit operation via a left double-click!!
//
//    ENDEDITCB GridEndEditCallback( ENDEDITINFO* pEEI, LPARAM lParam ) ==> This callback is invoked by CLiteGrid when 
//       an inplace edit control is extinguished by user action.  In the ENDEDITINFO struct, CLiteGrid provides the row 
//       and col coordinates of the cell that was edited, the "exit character" that terminated the inplace operation, a 
//       flag indicating whether or not the user changed the datum, and the new value for the datum (IAW the type of 
//       datum appearing in cell).  The callback can choose to reject or accept the new value; in case of rejection, 
//       CLiteGrid will reinitiate the inplace operation on the same cell.  The callback can also direct CLiteGrid to 
//       automatically navigate to a neighboring cell and initiate an inplace operation on that cell if the exit 
//       character is the TAB key or CTRL+navigational key (arrows, "PgUp", etc).  This feature allows the user to 
//       modify any number of parameters via keyboard navigation -- which is more efficient than having to "double-
//       click" each cell in turn.  The callback can customize how the user navigates around the grid, or leave it to 
//       CLiteGrid's default navigation rules:
//             CTRL+UpArrow ==> Move up one row, wrapping around to the bottom row if necessary, and skipping over 
//                fixed rows.  Column is unchanged.
//             CTRL+DnArrow ==> Move down one row, wrapping back to the first non-fixed row if necessary.
//             CTRL+LfArrow ==> Move to previous column, wrapping back to the rightmost col if necessary, and skipping 
//                over any fixed columns.  Row is unchanged.
//             CTRL+RtArrow ==> Move to the next column, wrapping back to the leftmost non-fixed col if necessary. 
//             TAB ==> Move to the next column, wrapping back to the leftmost non-fixed col OF THE NEXT ROW.  If 
//                we're on the bottom row, then we move back up to the first non-fixed row.
//       These rules are NOT identical to CGridCtrl's keyboard navigation rules in CGridCtrl::OnKeyDown().  We also do 
//       NOT take into account the possibility of "hidden" rows or columns!!
//
//       The callback function will STILL be invoked even if the user made no changes or cancelled the operation via 
//       the ESC key.  Extinguishing an inplace operation by changing the keyboard focus with the mouse (in which case 
//       the exit character is not defined) is taken to be the equivalent of confirming the change in data via the 
//       "Enter" (RETURN) key.
//
//    IPTREECB IpTreeCallback( LPARAM lParam, DWORD dwKey, 
//             CStringArray* pstrArLabels, CDWordArray* pdwArKeys, CByteArray* pbArHasKids ) ==> This callback is 
//       invoked directly by CLiteGrid's inplace tree control whenever it needs to "populate" a node in the tree.  The 
//       implementation of the inplace tree demands that every item in the tree be identified by a unique, nonzero 
//       32bit key, and the callback is responsible for ensuring this is the case.  See CInPlaceTree for details.
//
// Note the LPARAM argument in each of these callback functions.  The value of this argument is specified when the 
// callback function is installed, and it is passed to the callback each time it is invoked.  Since callback functions 
// are static -- which means they do not get the implied THIS reference -- the parent window class will typically use 
// the LPARAM argument to pass the THIS reference to the callback; otherwise, the callback will not have access to 
// instance members of the parent window!
//
// ==> Additional feature: "Label tip"
// Suppose each row of the grid represents an object defined by a set of parameters, with one parameter assigned to each 
// cell of the grid.  Suppose further that changing one of the parameters -- say, object type -- changes the identities 
// of the other parameters.  In this situation, it does not make sense to have fixed column "headers" describing the 
// parameter in each column.  One solution is to have two rows for each "object" -- parameter labels on the first row, 
// and the parameter values on the second.  This is a wasteful, potentially confusing presentation.  As an alternative, 
// we could provide a tooltip that displays an appropriate parameter label whenever the grid's focus cell changes.  This 
// "label tip" will remind novice users of what parameter each cell contains, while not "getting in the way" of more 
// experienced users.
//
// CLiteGrid uses CGridCtrl's existing titletip to implement this "label tip" in virtual mode.  The parent window must, 
// of course, provide a label on request.  CLiteGrid queries the parent for the label via the grid display callback or 
// the GVN_DISPINFO notification.  To do so, we introduce a special "state bit", GVIS_VIRTUALLABELTIP, which is set 
// when we're asking for a label tip rather than the cell's text content.  See OnSelChanged() for details.  If no label 
// text is provided or the GVIS_VIRTUALLABELTIP flag is cleared, the label tip will not be shown.  Note that, since we 
// use CGridCtrl's internal titletip infrastructure (class CTitleTip) for the label tip, the label will be extinguished 
// on a keypress or mouse motion.  We also have modified CTitleTip so that it can be set to disappear after a finite 
// display time.
//
// 
// CREDITS:
// (1) Article by Chris Maunder [08/30/2000, www.codeproject.com/miscctrl/gridctrl.asp] -- The MFC Grid Control, v2.21. 
// This extremely useful spreadsheet-like control (CGridCtrl) provides an efficient way to present modifiable tabular 
// data.  We've made a few minor modifications to its original implementation.  See /GridCtrl_src/GridCtrl.cpp.
//
//
// REVISION HISTORY:
// 30oct2002-- Began development.
// 04nov2002-- Added reflected notification message handler OnMouseClick() to implement cell content modifications via 
//             single mouse clicks (left or right).
// 07nov2002-- Modified to include a generic inplace tree control, CInPlaceTree.
// 13nov2002-- Added reflected notification handler OnSelChanged() to display a "label tip" when the focus cell is 
//             changed.
// 02dec2002-- Modified effect of the TAB navigation key.... Also, CLiteGrid now invokes the end-edit callback even if 
//             the user cancels the operation, or if it was cancelled programmatically via EndEditing().
// 04dec2002-- Left-click no longer has an editing effect, since it causes confusion when the user tries to initiate an 
//             inplace operation via a left double-click!  Instead, a right click alone is treated as an incrementing 
//             action, while a SHIFT + right click is treated as a decrementing action.
// 03jan2007-- Modified OnEditCell() to do nothing if the grid cell identified by row and column arguments does not 
//             exist. Prior to this change, if the grid had the keyboard focus but there was no focus cell yet, hitting 
//             a key would lead to a downstream debug assertion.
//===================================================================================================================== 


#include "stdafx.h"                          // standard MFC stuff

#include "litegrid.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//===================================================================================================================== 
// CONSTANTS
//===================================================================================================================== 

const UINT CLiteGrid::IDC_IPTXTEDIT       = 517;            // control IDs assigned to the internal inplace controls 
const UINT CLiteGrid::IDC_IPNUMEDIT       = 518;
const UINT CLiteGrid::IDC_IPCOMBO         = 519;
const UINT CLiteGrid::IDC_IPTREE          = 520;





IMPLEMENT_DYNCREATE( CLiteGrid, CGridCtrl )

BEGIN_MESSAGE_MAP( CLiteGrid, CGridCtrl )
   ON_NOTIFY_RANGE( NM_KILLFOCUS, CLiteGrid::IDC_IPTXTEDIT, CLiteGrid::IDC_IPTREE, OnEndInPlaceOp )
   ON_NOTIFY_REFLECT_EX( NM_RCLICK, OnRightClick )
   ON_NOTIFY_REFLECT_EX( GVN_SELCHANGED, OnSelChanged )
END_MESSAGE_MAP()



//===================================================================================================================== 
// CONSTRUCTION/DESTRUCTION
//===================================================================================================================== 

//=== CLiteGrid [constructor] ========================================================================================= 
//
//    Construct the grid control in virtual mode.  Required callbacks for editing operations are initially NULL, and 
//    inplace edit controls are not created until the first time they are used.
//
//    ARGS:       nRows/Cols        -- total # of rows and columns in grid initially.
//                nFixedRows/Cols   -- # of fixed rows and columns in grid initially.
//
CLiteGrid::CLiteGrid( int nRows /* =0 */, int nCols /* =0 */, int nFixedRows /* =0 */, int nFixedCols /* =0 */ ) 
   : CGridCtrl( nRows, nCols, nFixedRows, nFixedCols )
{
   SetVirtualMode( TRUE );                            // place in virtual mode, as this is the intended usage!!
   m_pfnEditCB = NULL;                                // required grid callbacks initially undefined
   m_pfnEndEditCB = NULL;
   m_pfnTreeInfoCB = NULL;
   m_cellEdit.row = m_cellEdit.col = -1;              // no grid cell is being edited inplace at this time
   m_iTypeEdit = LG_READONLY;
   m_pInPlaceTxtEdit = NULL;                          // each inplace control is created the first time it is used
   m_pInPlaceNumEdit = NULL;
   m_pInPlaceCombo = NULL;
   m_pInPlaceTree = NULL;
}


//=== ~CLiteGrid [destructor] ========================================================================================= 
//
//    Destroy any inplace controls that were created during the grid's lifetime.
//
//    ARGS:       NONE.
//
CLiteGrid::~CLiteGrid()
{
   if( m_pInPlaceTxtEdit != NULL ) delete m_pInPlaceTxtEdit;
   if( m_pInPlaceNumEdit != NULL ) delete m_pInPlaceNumEdit;
   if( m_pInPlaceCombo != NULL ) delete m_pInPlaceCombo;
   if( m_pInPlaceTree != NULL ) delete m_pInPlaceTree;
}



//===================================================================================================================== 
// MESSAGE MAP HANDLERS
//===================================================================================================================== 

//=== OnEndInPlaceOp ================================================================================================== 
//
//    Handles NM_KILLFOCUS notifications from inplace controls when they are extinguished by user action.
//
//    We report the results of the inplace operation -- even if the user cancelled or made no changes -- to the parent 
//    window via the "end-edit" callback function.  If the callback rejects the new value, we reinitiate the inplace 
//    operation on the same grid cell.  Otherwise, we initiate a new inplace operation on a nearby cell if the exit 
//    character is one of the recognized navigation keys -- see NavigateGrid() for details.  Note that the callback can 
//    prevent this automatic navigation feature by clearing the value of the exit character in the ENDEDITINFO 
//    structure.  It can also customize how the navigation keys move the focus cell through the grid by specifying the 
//    next cell to edit.
//
//    If the new cell value was accepted, we normally redraw that cell to reflect the new value -- unless explicitly 
//    instructed not to do so by the end-edit callback.
//
//    ARGS:       id       -- [in] inplace control's ID.
//                pNMHDR   -- [in] ptr to the generic WM_NOTIFY header. 
//                pResult  -- [out] return code.  ignored for NM_KILLFOCUS.
//
//    RETURNS:    NONE.
//
void CLiteGrid::OnEndInPlaceOp( UINT id, NMHDR* pNMHDR, LRESULT* pResult )
{
   *pResult = TRUE;                                                  // return value is irrelevant for NM_KILLFOCUS
   CCellID c = m_cellEdit;                                           // remember location of cell just edited 

   m_cellEdit.row = m_cellEdit.col = -1;                             // reset tracking vars for inplace op
   m_iTypeEdit = LG_READONLY;

   if( !IsValid( c ) ) return;                                       // just in case something went haywire!
   if( (!GetVirtualMode()) || m_pfnEndEditCB == NULL ) return;

   ENDEDITINFO eei;                                                  // prepare structure holding edit results:
   eei.cell = c;                                                     //    the cell that was edited
   eei.bReject = FALSE;                                              //    assume new value will be accepted
   eei.bNoRedraw = FALSE;                                            //    assume that we'll redraw the cell
   eei.cellNext.row = eei.cellNext.col = -1;                         //    next cell to edit, in case a navigation key 
                                                                     //    terminated the inplace operation

   if( id == IDC_IPTXTEDIT )                                         // get results from text string editor...
   {
      ASSERT( m_pInPlaceTxtEdit != NULL );
      eei.bIsChanged = m_pInPlaceTxtEdit->IsChanged();
      m_pInPlaceTxtEdit->GetWindowText( eei.strNew );
      eei.nExitChar = m_pInPlaceTxtEdit->GetExitChar();
   }
   else if( id == IDC_IPNUMEDIT )                                    // OR get results from numeric text editor...
   {
      ASSERT( m_pInPlaceNumEdit != NULL );
      eei.bIsChanged = m_pInPlaceNumEdit->IsChanged();
      eei.dNew = m_pInPlaceNumEdit->AsDouble();
      eei.nExitChar = m_pInPlaceNumEdit->GetExitChar();
   }
   else if( id == IDC_IPCOMBO )                                      // OR get results from combo box editor...
   {
      ASSERT( m_pInPlaceCombo != NULL );
      eei.bIsChanged = m_pInPlaceCombo->IsChanged();
      eei.dwNew = (DWORD) m_pInPlaceCombo->GetCurrentSelection();
      eei.nExitChar = m_pInPlaceCombo->GetExitChar();
   }
   else if( id == IDC_IPTREE )                                       // OR get results from inplace tree editor...
   {
      ASSERT( m_pInPlaceTree != NULL );
      eei.bIsChanged = m_pInPlaceTree->IsChanged();
      eei.dwNew = m_pInPlaceTree->GetSelectedKey();
      eei.nExitChar = m_pInPlaceTree->GetExitChar();
   }
   else                                                              // should NEVER get here!
   {
      ASSERT( FALSE );
      TRACE0( _T("\nUnrecog ctrlID in CLiteGrid::OnEndInPlaceOp()") );
      return;
   }

   if( !m_pfnEndEditCB( &eei, m_lpEndEditArg ) ) return;             // invoke "end-edit" callback; abort on failure 

   if( eei.nExitChar == VK_ESCAPE )                                  // if user cancelled the inplace operation, 
      return;                                                        // then we're done!

   if( !eei.bReject )                                                // if edit result was NOT rejected by callback... 
   {
      if( eei.bIsChanged && !eei.bNoRedraw ) RedrawCell( c );        // redraw cell just edited unless told not to

      if( IsValid( eei.cellNext ) )                                  // initiate new inplace op at valid cell specified 
         c = eei.cellNext;                                           // by the callback
      else                                                           // otherwise, implement default rules for choosing 
         NavigateGrid( c, eei.nExitChar );                           // the next cell to edit based on exit character
   }

   if( IsValid( c ) )                                                // initiate new inplace op on same cell (if value 
      OnEditCell( c.row, c.col, CPoint(-1,-1), VK_LBUTTON );         // was rejected) or a new valid grid cell
}


//=== OnRightClick ==================================================================================================== 
//
//    Handles reflected NM_RCLICK notification generated by the base class implementation.
//
//    Here we give the parent window an opportunity to modify a cell's contents automatically when the cell is right- 
//    clicked.  A right-click alone is interpreted as an increment action, while the click accompanied by the SHIFT key 
//    is taken as a decrement action.  The grid "edit" callback is invoked, with the cell's ID and the implied action.
//    If the callback indicates that the action has modified the cell's contents, the cell is redrawn.
//
//    If the callback does not modify the cell's contents as a result of the right click, OR if the callback is not 
//    defined, OR if the grid is not in virtual mode, then we revert to baseline behavior -- that is, the notification 
//    messages are forwarded to the parent window for handling.
//
//    ARGS:       pNMHDR   -- [in] ptr to an NM_GRIDVIEW struct, case as a generic WM_NOTIFY header. 
//                pResult  -- [out] return code.  ignored for NM_RCLICK.
//
//    RETURNS:    FALSE to allow parent window to handle notification; TRUE to prevent.
//
BOOL CLiteGrid::OnRightClick( NMHDR* pNMHDR, LRESULT* pResult )
{
   *pResult = TRUE;                                               // result code is ignored, anyway
   if( (!GetVirtualMode()) || m_pfnEditCB == NULL )               // inplace editing not supported in this case
      return( FALSE );

   NM_GRIDVIEW* pNMGV = (NM_GRIDVIEW*) pNMHDR;                    // so we can get identity of cell that was clicked
   BOOL bShift = ::GetKeyState( VK_SHIFT ) & 0x80;                // is SHIFT key down?

   EDITINFO ei;                                                   // prepare edit info structure...
   ei.cell.row = pNMGV->iRow;                                     //    identify cell to be edited
   ei.cell.col = pNMGV->iColumn;
   ei.iClick = bShift ? -1 : 1;                                   //    decr (w/SHIFT key) or incr action?

   if( !m_pfnEditCB( &ei, m_lpEditArg ) ) return( FALSE );        // let parent handle msg if grid edit callback fails 

   if( ei.iClick != 0 )                                           // if callback indicates change in cell contents, 
      RedrawCell( pNMGV->iRow, pNMGV->iColumn );                  // then redraw it!

   return( BOOL(ei.iClick != 0) );                                // let parent handle msg, too, if cell not changed
}


//=== OnSelChanged ==================================================================================================== 
//
//    Handles reflected GVN_SELCHANGED notifications generated by the base class implementation.
//
//    GVN_SELCHANGED is sent whenever the grid's focus cell changes.  Here we implement a "label tip" for the focused 
//    cell, querying the grid display callback (or sending a GVN_DISPINFO notification if the callback is not defined) 
//    for the label text and background color.  Like the rest of CLiteGrid's functionality, the label tip feature is 
//    available only when the grid is in virtual mode. 
//
//    The GV_ITEM structure within the GV_DISPINFO record is set up as follows:
//       GV_ITEM.row,col      ==> row & col of cell to be "labelled".
//       GV_ITEM.mask         ==> GVIF_TEXT --> we request a text string for the label.
//       GV_ITEM.nState       ==> GVIS_VIRTUALLABELTIP
//       GV_ITEM.strText      ==> put the label string here; initially, it is empty.
//    In response, the callback or GVN_DISPINFO handler should provide the label text.  If the returned label is an 
//    empty string or the GVIS_VIRTUALLABELTIP state flag is cleared, the label tip will not be shown.
//
//    ARGS:       pNMHDR   -- [in] ptr to an NM_GRIDVIEW struct, case as a generic WM_NOTIFY header. 
//                pResult  -- [out] return code.  ignored for GVN_SELCHANGED.
//
//    RETURNS:    TRUE to allow parent window to handle notification; FALSE to prevent.
//
BOOL CLiteGrid::OnSelChanged( NMHDR* pNMHDR, LRESULT* pResult )
{
   *pResult = TRUE;                                               // result code is ignored, anyway
   NM_GRIDVIEW* pNMGV = (NM_GRIDVIEW*) pNMHDR;                    // so we can get identify of cell that got focus 
   int iRow = pNMGV->iRow;
   int iCol = pNMGV->iColumn;

   if( (!GetVirtualMode()) ||                                     // label tip feature available only in virtual mode
       (!IsValid( iRow, iCol )) )                                 // must be a valid cell to have a label tip!
      return( TRUE );

   GV_DISPINFO gvdi;                                              // prepare display request for label text 
   gvdi.item.row = iRow;
   gvdi.item.col = iCol;
   gvdi.item.mask = GVIF_TEXT;
   gvdi.item.nState = GVIS_VIRTUALLABELTIP;
   gvdi.item.strText.Empty();

   if( m_pfnCallback )                                            // send request by callback or GVN_DISPINFO notif
      m_pfnCallback( &gvdi, m_lParam );
   else
      SendDisplayRequestToParent( &gvdi );

   if( (gvdi.item.nState & GVIS_VIRTUALLABELTIP) &&               // if a label is to be shown, show it now
       !gvdi.item.strText.IsEmpty() )
   {
      m_TitleTip.Hide();                                          //    make sure no titletip is currently visible

      CGridCellBase* pCell =                                      //    for default cell characteristics
         GetDefaultCell( iRow<m_nFixedRows, iCol<m_nFixedCols );
      CRect rCell, rTip;                                          //    boundary rects for grid cell and the label tip 

      if( pCell &&                                                //    if we get the info we need, show the titletip
          GetCellRect( iRow, iCol, rCell ) )
      {
         rTip = rCell;
         rTip.OffsetRect( 0, -rCell.Height() );                   //    put label tip's rect ABOVE grid cell itself
         m_TitleTip.Show( rTip, gvdi.item.strText,  0, rCell,
            pCell->GetFont(), GetTitleTipTextClr(), 
            GetTitleTipBackClr(), TRUE, 500 );                    //    show it always, and for a set time period
      }
   }

   return( TRUE );
}



//===================================================================================================================== 
// IMPLEMENTATION
//===================================================================================================================== 

//=== OnEditCell [base override] ====================================================================================== 
//
//    Initiate an inplace edit operation on the specified grid cell.
//
//    This CGridCtrl override is called whenever user action dictates that we initiate editing of a cell's contents.
//    By overriding this method, the user will be able to initiate the appropriate inplace edit control on the virtual 
//    grid (which is read-only in the baseline CGridCtrl implementation) via any of the following methods:
//       1) Double-clicking on a cell that has modifiable contents.
//       2) Pressing the F2 key when the current "focus cell" is modifiable.
//       3) Hitting any character key when the current "focus cell" is modifiable.
//       4) Mousedown on a cell, then release mouse without moving it
//
//    If the grid is NOT in virtual mode or either or the requisite callbacks are NOT installed, we merely call the 
//    base class version -- so CLiteGrid will behave exactly like the base class.  Otherwise, we query the grid edit 
//    callback for the necessary editing information.  If the callback's response indicates that the specified grid 
//    cell is editable, we prepare and display the appropriate inplace edit control.  If that control does not yet 
//    exist (because it has not been required since grid creation), we create it here.
//
//    ARGS:       nRow, nCol  -- [in] location of grid cell to be edited.
//                point       -- [in] location of mouse cursor if inplace edit was initiated by mouse action.
//                nChar       -- [in] character key that initiated inplace edit.
//
//    RETURNS:    NONE.
//
void CLiteGrid::OnEditCell( int nRow, int nCol, CPoint point, UINT nChar )
{
   if( (!GetVirtualMode()) ||                                           // revert to base class behavior if not in 
       m_pfnEditCB == NULL || m_pfnEndEditCB == NULL )                  // virtual mode or callbacks not installed 
   {
      CGridCtrl::OnEditCell( nRow, nCol, point, nChar );
      return;
   }

   CCellID c(nRow, nCol);                                               // the grid cell under consideration -- save a 
                                                                        // copy in case callback foolishly changes it
   if(!IsValid(c)) return;                                              // if cell invalid, do nothing!

   SetFocusCell( c );                                                   // make sure it gets the focus 
   EnsureVisible( c );                                                  // must also be visible (or cell rect undef!) 

   if( !ScrollObscuringParentForm( c ) )                                // if grid is on a scrollable form that is  
      return;                                                           // obscuring cell, try to scroll it into view

   EDITINFO ei;                                                         // prepare edit info structure...
   ei.cell = c;                                                         //    identify cell to be edited
   ei.iClick = 0;                                                       //    this was NOT due to a mouse click!
   ei.iType = LG_READONLY;                                              //    assume it is read-only for now

   if( !m_pfnEditCB( &ei, m_lpEditArg ) ) return;                       // abort if grid edit callback fails

   if( ei.iType == LG_READONLY ) return;                                // abort if the grid cell is read-only

   CRect rect;                                                          // inplace ctrl will be shown directly on top 
   if( !GetCellRect( c, rect ) ) return;                                // of the grid cell to be modified

   if( nChar == VK_LBUTTON || nChar == VK_F2 )                          // don't pass on these initiating keys to the 
      nChar = 0;                                                        // inplace text controls

   if( ei.iType == LG_TEXTSTR )                                         // invoke text string editor, creating the 
   {                                                                    // control upon first use...
      if( m_pInPlaceTxtEdit == NULL ) 
      {
         m_pInPlaceTxtEdit = new CInPlaceTextEdit( this, ES_LEFT, IDC_IPTXTEDIT ); 
         if( m_pInPlaceTxtEdit == NULL )
         {
            TRACE0( _T("\nCInPlaceTextEdit creation failed in CLiteGrid::OnEditCell()") );
            return;
         }
      }

      if( !m_pInPlaceTxtEdit->BeginEdit( NULL, rect, ei.strCurrent, nChar ) ) 
         return;
   }
   else if( ei.iType == LG_NUMSTR )                                     // OR invoke numeric text editor, creating ctrl 
   {                                                                    // upon first use...
      if( m_pInPlaceNumEdit == NULL ) 
      {
         m_pInPlaceNumEdit = new CInPlaceNumEdit( this, ES_LEFT, IDC_IPNUMEDIT ); 
         if( m_pInPlaceNumEdit == NULL )
         {
            TRACE0( _T("\nCInPlaceNumEdit creation failed in CLiteGrid::OnEditCell()") );
            return;
         }
      }

      if( !m_pInPlaceNumEdit->BeginEdit( NULL, rect, ei.numFmt, ei.dCurrent, nChar ) )
         return;
   }
   else if( ei.iType == LG_MULTICHOICE )                                // OR invoke multiple-choice combo box editor, 
   {                                                                    // creating ctrl upon first use...
      if( m_pInPlaceCombo == NULL ) 
      {
         m_pInPlaceCombo = new CInPlaceCombo( this, 0, IDC_IPCOMBO ); 
         if( m_pInPlaceCombo == NULL )
         {
            TRACE0( _T("\nCInPlaceCombo creation failed in CLiteGrid::OnEditCell()") );
            return;
         }
      }

      if( !m_pInPlaceCombo->BeginEdit( NULL, rect, FALSE, ei.strArChoices, ei.iCurrent ) )
         return;
   }
   else                                                                 // OR invoke tree-choice editor, creating the 
   {                                                                    // inplace tree upon first use...
      if( m_pInPlaceTree == NULL )
      {
         if( m_pfnTreeInfoCB == NULL )                                  //    abort if lacking tree info callback fcn 
         {
            TRACE0( _T("\nCLiteGrid::OnEditCell(): Required IPTREECB not installed yet!") );
            return;
         }
         m_pInPlaceTree = new CInPlaceTree( this, 0, IDC_IPTREE );
         if( m_pInPlaceTree == NULL )
         {
            TRACE0( _T("\nCInPlaceTree creation failed in CLiteGrid::OnEditCell()") );
            return;
         }
         m_pInPlaceTree->SetCallback( m_pfnTreeInfoCB, m_lpTreeInfoArg );
      }

      CRect rGrid;                                                      //    expand cell rect so that it is at least 
      GetClientRect( rGrid );                                           //    10 cells high and 200pix wide, but make 
      int iHt = 10 * rect.Height();                                     //    sure it's still contained in grid rect! 
      rect.bottom = rect.top + iHt;
      if( rect.bottom > rGrid.bottom )
      {
         rect.bottom = rGrid.bottom;
         rect.top = rect.bottom - iHt;
         if( rect.top < rGrid.top ) rect.top = rGrid.top;
      }
      if( rect.Width() < 200 )
      {
         rect.right = rect.left + 200;
         if( rect.right > rGrid.right )
         {
            rect.right = rGrid.right;
            rect.left = rect.right - 200;
            if( rect.left < rGrid.left ) rect.left = rGrid.left;
         }
      }

      if( !m_pInPlaceTree->BeginEdit( NULL, rect, ei.dwArKeyChain ) )
         return;
   }
   m_cellEdit = c;                                                      // remember location & data type of cell being 
   m_iTypeEdit = ei.iType;                                              // edited
}


//=== EndEditing [base override] ====================================================================================== 
//
//    Terminate inplace editing in response to certain user interactions with the grid control.
//
//    This CGridCtrl overridable is invoked when the user performs certain interactions with the grid that may not 
//    necessarily transfer the keyboard focus away from any inplace control that might be sitting on top of it -- such 
//    as mousedowns on the scroll bars, a resizing operation (programmatic or user initiated), or a right-click.  Our 
//    response is to CANCEL any inplace operation in progress.  We invoke the end-edit CB to inform the parent window 
//    that the inplace operation was cancelled.
//
//    ARGS:       NONE.
//
//    RETURNS:    NONE.
//
void CLiteGrid::EndEditing()
{
   if( (!GetVirtualMode()) ||                                  // revert to base class behavior if not in virtual mode 
       m_pfnEditCB == NULL || m_pfnEndEditCB == NULL )         // or if required callbacks are not installed
      CGridCtrl::EndEditing();
   else if( IsEditing() )                                      // if an inplace edit op was in progress...
   {
      if( m_iTypeEdit == LG_TEXTSTR )                          //    extinguish the relevant inplace tool
         m_pInPlaceTxtEdit->CancelEdit(); 
      else if( m_iTypeEdit == LG_NUMSTR ) 
         m_pInPlaceNumEdit->CancelEdit();
      else if( m_iTypeEdit == LG_MULTICHOICE ) 
         m_pInPlaceCombo->CancelEdit();
      else if( m_iTypeEdit == LG_TREECHOICE ) 
         m_pInPlaceTree->CancelEdit();

      ENDEDITINFO eei;                                         //    invoke end-edit CB to inform parent that the 
      eei.cell = m_cellEdit;                                   //    inplace operation was cancelled
      eei.bIsChanged = FALSE;
      eei.nExitChar = VK_ESCAPE;
      m_pfnEndEditCB( &eei, m_lpEndEditArg );

      m_cellEdit.row = m_cellEdit.col = -1;
      m_iTypeEdit = LG_READONLY;
   }
}


//=== IsNavigationKey ================================================================================================= 
//
//    Does character key code correspond to one of the keys recognized by CLiteGrid for navigating to and initiating an 
//    inplace operation on a grid cell?
//
//    ARGS:       nChar -- [in] character key code.
//
//    RETURNS:    TRUE if it is a navigation key; FALSE otherwise.
//
BOOL CLiteGrid::IsNavigationKey( UINT nChar )
{
   return( nChar==VK_TAB || nChar==VK_UP || nChar==VK_DOWN || nChar==VK_RIGHT || nChar==VK_LEFT );
}


//=== NavigateGrid ==================================================================================================== 
//
//    Implements default navigation rules for CLiteGrid, as follows:
//
//       VK_UP ==> Move up one row, wrapping around to the bottom row if necessary, and skipping over fixed rows. 
//          Column is unchanged.
//       VK_DOWN ==> Move down one row, wrapping back to the first non-fixed row if necessary.
//       VK_LEFT ==> Move to previous column, wrapping back to the rightmost col if necessary, and skipping over any 
//          fixed columns.  Row is unchanged.
//       VK_RIGHT ==> Move to the next column, wrapping back to the leftmost non-fixed col if necessary. 
//       VK_TAB ==> Move to the next column, wrapping back to the leftmost non-fixed col OF THE NEXT ROW.  If we're 
//          on the last row, we also wrap back up to the first non-fixed row.
//
//    If we navigate to the cell we started from, then we set the ending cell is set to an invalid location (this could 
//    happen if there's only one non-fixed row or column).
//
//    ARGS:       c     -- [in] the starting cell location.
//                      -- [out] ending cell loc, or an invalid loc if char key code is not a navigation key.
//                nChar -- [in] character key code.
//
//    RETURNS:    NONE.
//
VOID CLiteGrid::NavigateGrid( CCellID& c, UINT nChar )
{
   if( GetRowCount() == GetFixedRowCount() || GetColumnCount() == GetFixedColumnCount() )    // no non-fixed cells!
   {
      c.row = c.col = -1;
      return;
   }

   CCellID cNew = c;
   switch( nChar )
   {
      case VK_UP :
         --cNew.row;
         if( cNew.row < GetFixedRowCount() ) cNew.row = GetRowCount() - 1;
         break;
      case VK_DOWN :
         ++cNew.row;
         if( cNew.row >= GetRowCount() ) cNew.row = GetFixedRowCount();
         break;
      case VK_LEFT :
         --cNew.col;
         if( cNew.col < GetFixedColumnCount() ) cNew.col = GetColumnCount() - 1;
         break;
      case VK_RIGHT :
      case VK_TAB :
         ++cNew.col;
         if( cNew.col >= GetColumnCount() ) 
         {
            cNew.col = GetFixedColumnCount();
            if( nChar == VK_TAB )
            {
               ++cNew.row;
               if( cNew.row >= GetRowCount() ) cNew.row = GetFixedRowCount();
            }
         }
         break;
      default :
         cNew.row = cNew.col = -1;
         break;
   }

   if( cNew == c ) c.row = c.col = -1; 
   else c = cNew;
}


//=== ScrollObscuringParentForm ======================================================================================= 
//
//    If the grid control is partially obscured by its parent window, a user can easily use the grid navigation keys to 
//    initiate an inplace operation on an obscured grid cell.  This is undesirable -- and confusing from the user's 
//    point of view.  This method is an inelegant attempt to fix the problem for CLiteGrid, but NOT for the underlying 
//    CGridCtrl.  It is called by OnEditCell() whenever an inplace operation is initiated.
//
//    First, this method checks to see if the specified grid cell's bounding rectangle is obscured or partially 
//    obscured by the grid's parent window.  If it is obscured, AND IF the grid's parent window is derived from 
//    CFormView, this method will attempt to scroll the parent window so that the cell is fully visible.  IF this 
//    "fix" is successful, then OnEditCell() will permit inplace editing of the cell's contents; else it aborts -- see 
//    also OnEditCell().
//
//    ARGS:       c  -- [in] the grid cell to check
//
//    RETURNS:    TRUE if grid cell is not obscured or if we successfully scrolled parent window to make grid cell 
//                visible; FALSE otherwise.
//
BOOL CLiteGrid::ScrollObscuringParentForm( const CCellID& c )
{
   CWnd* pParent = GetParent();                                   // get parent window; if there is none, assume that 
   if( pParent == NULL ) return( TRUE );                          // grid cell is NOT obsured

   CRect parentR;                                                 // get parent's client rect
   pParent->GetClientRect( parentR );

   CRect cellR;                                                   // get cell's bounding rect, converted to parent 
   if( !GetCellRect( c, cellR ) ) return( FALSE );                // wnd's client coords
   MapWindowPoints( pParent, cellR );

   if( (cellR.left >= 0) && (cellR.right <= parentR.right) &&     // if the cell is NOT obscured by parent, then we're 
       (cellR.top >= 0) && (cellR.bottom <= parentR.bottom) )     // done!
      return( TRUE );

   if( !pParent->IsKindOf( RUNTIME_CLASS(CFormView) ) )           // if cell is obscured and parent is not derived from 
      return( FALSE );                                            // CFormView, then we can't attempt scroll here

   CFormView* pFormView = (CFormView*) pParent;                   // otherwise, get the parent form's current scroll 
   CPoint ptCurrPos = pFormView->GetScrollPosition();             // position, calculate adjustments to bring the grid 
   CPoint ptNewPos = ptCurrPos;                                   // cell into view, then scroll the parent...
   if( cellR.left < 0 )
   {
      ptNewPos.x += cellR.left - 2;
      if( ptNewPos.x < 0 ) ptNewPos.x = 0;
   }
   else if( cellR.right > parentR.right ) 
      ptNewPos.x += cellR.right - parentR.right + 2;
   if( cellR.top < 0 )
   {
      ptNewPos.y += cellR.top - 2;
      if( ptNewPos.y < 0 ) ptNewPos.y = 0;
   }
   else if( cellR.bottom > parentR.bottom )
      ptNewPos.y += cellR.bottom - parentR.bottom + 2;

   pFormView->ScrollToPosition( ptNewPos );

   GetCellRect( c, cellR );                                       // now check to make sure cell is now unobscured!
   MapWindowPoints( pFormView, cellR ); 
   return( (cellR.left >= 0) && (cellR.right <= parentR.right) && 
           (cellR.top >= 0) && (cellR.bottom <= parentR.bottom) );
}
