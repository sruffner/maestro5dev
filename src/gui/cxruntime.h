//===================================================================================================================== 
//
// cxruntime.h : Declaration of class CCxRuntime.
//
// ****** FOR DESCRIPTION, REVISION HISTORY, ETC, SEE IMPLEMENTATION FILE ******
//
//===================================================================================================================== 


#if !defined(CXRUNTIME_H__INCLUDED_)
#define CXRUNTIME_H__INCLUDED_


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "cxipc.h"               // constants and IPC interface data structs for Maestro-MaestroDRIVER communications
#include "cxchannel.h"           // CCxChannel -- encapsulates trace attributes for all defined Maestro signal channels 
#include "cxeyelink.h"           // CCxEyeLink -- UNDER DEV connection to EyeLink tracker over Win32 Ethernet


class CCxControlPanel;           // forward declarations...
class CGraphBar;
class CXYPlotBar;
class CCxSpikeHistBar;
class CCxTrialSequencer;


//===================================================================================================================== 
// Declaration of class CCxRuntime
//===================================================================================================================== 
//
class CCxRuntime : public CObject
{
   DECLARE_DYNAMIC( CCxRuntime )

//===================================================================================================================== 
// CONSTANTS
//===================================================================================================================== 
public:
   static const int  IdleMode;                  // Maestro operational modes...
   static const int  TestMode;
   static const int  TrialMode;
   static const int  ContMode;
   static const int  NullMode;

protected:
   static LPCTSTR DRVR_EXECUTABLE;              // name of MAESTRODRIVER executable file

   static LPCTSTR WMSG_ORPHANDRVR;              // warning/error/info messages generated by this object
   static LPCTSTR EMSG_DATAPATHTOOLONG;
   static LPCTSTR EMSG_CANTKILLORPHAN; 
   static LPCTSTR EMSG_CANTKILLORPHAN2;
   static LPCTSTR EMSG_IPCFAILED;
   static LPCTSTR EMSG_DRVRSYNCFAILED;
   static LPCTSTR EMSG_DRVRDIEDINSTARTUP; 
   static LPCTSTR EMSG_DRVRNOTRESPONDING;
   static LPCTSTR EMSG_GRACEFULSTOPFAILED;


//===================================================================================================================== 
// DATA OBJECTS
//===================================================================================================================== 
protected:
   BOOL                 m_bDriverOn;            // TRUE when MAESTRODRIVER is running 
   HANDLE               m_hRtStopMutex;         // RTX mutex always held by MAESTRODRIVER; signals when driver dies
   HANDLE               m_hRtShared;            // RTX handle to shared memory for Maestro<->driver communications
   volatile PCXIPCSM    m_pShm;                 // ptr to the structure encapsulating the shared memory object for IPC

   CCxControlPanel*     m_pModePanel;           // ptr to the "master" mode control panel 
   CGraphBar*           m_pTracePanel;          // ptr to the data trace graph display 
   CXYPlotBar*          m_pPlotPanel;           // ptr to the eye-target XY position plot
   CCxSpikeHistBar*     m_pHistPanel;           // ptr to the spike histograms display panel (Trial mode use only)

   WORD                 m_wChanKey;             // Maestro key of chan cfg defining the currently displayed data traces
   CCxChannel           m_chDisplay;            // a private *copy* of the above channel cfg object

   WORD                 m_wNextChanKey;         // in TrialMode only, this is key of chan cfg and a private copy of the 
   CCxChannel           m_chNext;               // assoc chan cfg object for the trial currently being run; when the 
                                                // the trial is over, the collected data is displayed in the data 
                                                // trace display IAW this chan cfg

   CCxEyeLink           m_EyeLink;

//===================================================================================================================== 
// CONSTRUCTION/DESTRUCTION
//===================================================================================================================== 

public:
   CCxRuntime(); 
   ~CCxRuntime();


//===================================================================================================================== 
// ATTRIBUTES
//===================================================================================================================== 
public:
   static int MaxTraces() { return( CX_NTRACES ); }      // max # of displayed data traces supported by CXDRIVER


//===================================================================================================================== 
// OPERATIONS 
//===================================================================================================================== 
public:
   BOOL RegisterGUI( CCxControlPanel* pMode,             // (un)register GUI elements that display runtime data or  
      CGraphBar* pGraph, CXYPlotBar* pXYPlot,            // control runtime state
      CCxSpikeHistBar *pHist );
   VOID UnregisterGUI();

   BOOL Start();                                         // start the master runtime controller and MAESTRODRIVER
   VOID Stop( const BOOL bGraceful = TRUE );             // stop the master runtime controller and MAESTRODRIVER 
   BOOL IsOn() const { return(m_bDriverOn); }            // is runtime available (MAESTRODRIVER must be running) 

   int GetMode() const;                                  // retrieve current operational mode
   BOOL IsModeEnabled( const int iMode ) const;          // is specified operational mode enabled?

   BOOL Service();                                       // service any Maestro<->driver transactions in the current 
                                                         // operational mode --- CALL FREQUENTLY

   // check Eyelink tracker status and update relevant GUI as needed
   VOID ServiceEyelink();

   BOOL IsEyelinkConnected() { return(m_EyeLink.IsConnected()); }
   BOOL IsEyelinkRecording() { return(m_EyeLink.IsRecording()); }
   BOOL DisconnectEyelink() { return(m_EyeLink.Disconnect()); }
   BOOL ConnectEyelink() { return(IsOn() ? m_EyeLink.Connect(m_pShm) : FALSE); }
   BOOL SetEyelinkCal(BOOL isX, BOOL isOfs, int value) { return(m_EyeLink.SetCalParam(isX, isOfs, value)); }
   int GetEyelinkCal(BOOL isX, BOOL isOfs) { return(m_EyeLink.GetCalParam(isX, isOfs)); }
   int GetEyelinkVelFilterWidth() { return(m_EyeLink.GetVelocityFilterWidth()); }
   BOOL SetEyelinkVelFilterWidth(int value) { return(m_EyeLink.SetVelocityFilterWidth(value)); }

   BOOL IsEmptyMessageQueue() const;                           // TRUE if MAESTRODRIVER message queue is empty
   BOOL ServiceMessageQueue();                           // pop next msg off MAESTRODRIVER message queue and display it 

   WORD GetTraces() const;                                     // Maestro key of chan cfg currently attached to trace disp 
   WORD SetTraces( const WORD wKey, const int iDur );    // atch a new chan cfg obj to trace display & reinit [BLOCKS] 
   VOID OnChangeTraces();                                // update data trace facility IAW changes in chan cfg 
   int ServiceTraces();                                  // service data trace facility
   VOID StopTraces() { UpdateTraces( -1 ); }             // stop data trace facility, flushing trace data buffers 
   VOID ResetTraces() { SetTraces(CX_NULLOBJ_KEY, 0); }  // reset data trace facility, clearing trace display. 
protected:
   VOID ModifyTraces(const BOOL bInit, const int iDur);  // modify data trace display, possibly reinitializing it
   VOID UpdateTraces( const int nSamples );              // update data traces by specified # of samples (flush buffers 
                                                         // and halt data tracing if #samples < 0) 
   VOID SetupDelayedTrialTraces(                         // puts trace display in "delayed" mode and sets intv [t0..t1] 
            WORD key, LPCTSTR lbl, int t0, int t1 );     // spanned by next trace set.  Trial mode ONLY.  Currently 
                                                         // displayed traces should be unaffected!

public:
   BOOL StartEventStream();                              // enable and start streaming of digi events fr MAESTRODRIVER
   BOOL ServiceEventStream();                            // service the digital event stream buffers
   VOID StopEventStream() { UpdateEventStream(-1); }     // stop event stream, flush buffers, and disable
   BOOL HasEventStreamOverflowed() const                 // TRUE if event streaming stopped due to buffer overflow
   {
      return( m_bDriverOn && m_pShm->bEventOverflow );
   }
protected:
   VOID UpdateEventStream( const int nEvents );          // consume events from the event stream buffers

public:
   BOOL ServicePositionPlot();                           // service eye-target position plot facility 
   BOOL GetCursorInPositionPlot(float& fx, float& fy);   // get pos of mouse cursor in pos plot, in visual deg
protected:
   VOID ConfigurePositionPlot();                         // set up eye-target position plot

public:
   BOOL CanUpdateVideoCfg();                             // is a video display cfg update currently permissible?
   BOOL UpdateVideoCfg();                                // send video dsp cfg to MAESTRODRIVER via CX_SETDISPLAY cmd 
   BOOL CanUpdateFixRewSettings();                       // is a fix/reward settings update currently permissible?
   BOOL UpdateFixRewSettings();                          // send fix/rew setgs to MAESTRODRIVER via CX_FIXREWSETTINGS  

private:
   struct RMVideoMode                                    // an RMVideo display mode:
   {
      int w, h;                                          //    screen width and height in pixels
      int rate;                                          //    nominal refresh rate in Hz
   };
   int m_nModes;                                         // number of available RMVideo display modes
   int m_iCurrMode;                                      // index of the current display mode; -1 if RMVideo unavail.
   RMVideoMode m_rmvModes[RMV_MAXVMODES];              // info on available display modes
   float m_rmvFrameRate;                                 // measured frame rate for the current RMVideo display mode
   float m_rmvGamma[3];                                // RMVideo display gamma-correction for R,G,B

   // summary information on a file (image or video) in the RMVideo media store: file name; image or video frame size
   // in pixels; suggested video playback rate in Hz and approximate duration in seconds. Any unknown parameter is
   // set to 0. For image files, both rate and duration are set to negative values to identify the file as an image.
   struct RMVMediaFile  
   {
      char name[RMV_MVF_LEN+1]; 
      int width; 
      int height; 
      float rate; 
      float dur; 
   };
   struct RMVMediaFolder                                 // a folder in the RMVideo media store
   {
      char name[RMV_MVF_LEN+1];                          //    the folder name
      int nFiles;                                        //    list of media files currently in this folder
      RMVMediaFile files[RMV_MVF_LIMIT];
   };

   int m_nMediaFolders;                                  // a "table of contents" for the RMVideo media store
   RMVMediaFolder m_mediaFolders[RMV_MVF_LIMIT];

   VOID RetrieveRMVideoDisplayData();                    // retrieves RMVideo display modes, monitor gamma
   VOID RetrieveRMVideoMediaStoreTOC();                  // retrieves RMVideo media store table of contents

public:
   int GetRMVideoScreenW() const;                        // get current width of RMVideo display in pixels
   int GetRMVideoScreenH() const;                        // get current height of RMVideo display in pixels
   float GetRMVideoFrameRate() const;                    // get measured frame rate of RMVideo display in Hz
   int GetNumRMVideoModes() const;                       // get number of available RMVideo display modes
   BOOL GetRMVideoModeDesc(int i, CString& desc) const;  // get brief description of one of the RMVideo display modes
   int GetCurrRMVideoMode() const;                       // get index of current RMVideo display mode
   BOOL SetCurrRMVideoMode(int i);                       // switch to a different RMVideo display mode
   
   BOOL GetRMVGamma(float& r, float& g, float& b) const; // get current gamma-correction factors for RMVideo display
   BOOL SetRMVGamma(float& r, float& g, float& b);       // set current gamma-correction factors for RMVideo display

   int GetNumRMVMediaFolders() const;                    // get number of folders in RMVideo media store
   BOOL GetRMVMediaFolder(int i, CString& folder) const; // get name of i-th folder in media store
   int GetNumRMVMediaFiles(int i) const;                 // get number of media files in i-th folder in media store
   BOOL GetRMVMediaInfo(int i, int j, CString& name,     // get info on j-th media file in i-th folder in media store
      CString& desc) const;
   
   BOOL DeleteRMVMediaFile(int i, int j);                // delete a media file (or folder) in RMVideo media store
   BOOL DownloadRMVMediaFile(LPCTSTR path, int iFolder,  // download a media file to the RMVideo media store
         LPCTSTR folderNew, LPCTSTR file);


   DWORD GetProtocolStatus() const;                      // retrieve/clear protocol status
   VOID ClearProtocolStatus() 
   { 
      if( m_pShm ) 
         m_pShm->dwResult = (GetMode() == TrialMode) ? CX_FT_DONE : 0; 
   }

   int GetNumRewardsDelivered() const                    // retrieve total #rewards delivered thus far
   {
      return( (m_pShm==NULL) ? 0 : m_pShm->iNumRewards ); 
   }
   int GetCumulativeReward() const                       // retrieve the cumulative reward, ie, sum of reward pulse 
   {                                                     // lengths delivered thus far, in milliseconds
      return( (m_pShm==NULL) ? 0 : m_pShm->iTotalRewardMS );
   }
   BOOL ResetRewardStats()                               // clear the reward stats
   {
      if( m_pShm ) 
      {
         m_pShm->iNumRewards = 0;
         m_pShm->iTotalRewardMS = 0;
      }
      return( BOOL(m_pShm != NULL) );
   }

                                                         // TrialMode-specific support:
   BOOL LoadTargetList(const CCxTrialSequencer *pCtrl);  // load target list in IPC with all targets participating in 
                                                         //    a trial sequence
   BOOL StartTrial( CCxTrialSequencer* pCtrl,            // load a trial defn into MAESTRODRIVER IPC and start the trial 
                    LPCTSTR strData, BOOL bSpikesOn );   //
   VOID SetTransform(const CCxTrialSequencer* pCtrl);    // set global transform factors used to generate trial codes
                                                         //    MAESTRODRIVER stores these in trial data file header.
   BOOL IsTrialRunning() const;                          // is a trial in progress?
   int GetLastTrialLen() const;                          // return elapsed time of last trial presented
   float GetRPDistroBehavResp() const;                   // return behavioral response to an "R/P Distro" trial

   // access to flag in MAESTRODRIVER IPC that controls whether any RMVideo duplicate frames may occur during a trial.
   // if unset, a single duplicate frame will cause the trial to abort; if set, up to 3 duplicate frames may occur before
   // the trial is aborted
   BOOL AllowRMVDuplFrames() const { return((m_pShm != NULL) ? m_pShm->bTolRMVDuplFrame : FALSE); }
   VOID SetAllowRMVDuplFrames(BOOL bAllow) { if(m_pShm) m_pShm->bTolRMVDuplFrame = bAllow; }
   VOID ToggleAllowRMVDuplFrames(){ if(m_pShm) m_pShm->bTolRMVDuplFrame = !m_pShm->bTolRMVDuplFrame; }

                                                         // ContMode-specific support:
   BOOL LoadActiveTargets( int n, WORD* pwKeys );        // load the active target list
   BOOL LoadStimulusRun( WORD wKey, BOOL bStop );        // load a stimulus run defn into MAESTRODRIVER IPC
   BOOL StartStimulusRun();                              // issue cmd to start a stimulus run
   BOOL StopStimulusRun( BOOL bNow, BOOL bStopRec );     // issue cmd to stop stimulus run now or at end of duty cycle 
   BOOL StartRecord( LPCTSTR strData, BOOL bSpikesOn,    // start recording data to file
         WORD wRunKey, WORD wChanKey );
   BOOL StopRecord( BOOL& bSave );                       // stop recording; optionally discard data file

   BOOL SendCommand(                                     // send cmd to MAESTRODRIVER and wait for response [BLOCKS]
      DWORD& dwCmd, int *piData, float *pfData, 
      int niCmd, int nfCmd, int niRsp, int nfRsp,
      int tWait = 50, char *pcData = NULL, int ncCmd = 0, 
      int ncRsp = 0 );

   int ConvertVoltsToRaw( float fVolt, BOOL isAI ) const;      // convert volts to raw DAC value for an AI or AO datum
   float ConvertRawToVolts( int iDac, BOOL isAI ) const;       // convert raw DAC value to volts for an AI or AO datum

   VOID ToggleChairPresent( )                            // access to some option flags in MAESTRODRIVER IPC
   { if( m_pShm ) m_pShm->bChairPresent = !m_pShm->bChairPresent; }
   VOID SetChairPresent( BOOL bPresent )
   { if( m_pShm ) m_pShm->bChairPresent = bPresent; }
   BOOL IsChairPresent() const
   { return( (m_pShm!=NULL) ? m_pShm->bChairPresent : FALSE ); }
   VOID ToggleSpikeTraceOn()
   { if( m_pShm ) m_pShm->bSaveSpikeTrace = !m_pShm->bSaveSpikeTrace; }
   VOID SetSpikeTraceOn( BOOL bOn )
   { if( m_pShm ) m_pShm->bSaveSpikeTrace = bOn; }
   BOOL IsSpikeTraceOn() const
   { return( (m_pShm!=NULL) ? m_pShm->bSaveSpikeTrace : FALSE ); }

   int GetVStabSlidingWindow() const;                    // size of sliding window average used to smooth eye pos
   BOOL SetVStabSlidingWindow(int sz);                   // during vel stabilization in Trial Mode
   
   DWORD GetHWStatus() const                             // retrieve hardware status flags (availability, etc.)
   {return( (m_pShm!=NULL) ? m_pShm->dwHWStatus : 0 );}
   int GetNumAI() const                                  // #channels available on supported analog input device 
   {return( (m_pShm!=NULL) ? m_pShm->nAIChannels : 0 );}
   int GetNumAO() const                                  // #channels available on supported analog output device
   {return( (m_pShm!=NULL) ? m_pShm->nAOChannels : 0 );}
   int GetNumTDI() const                                 // # digital inputs available on supported event timer device 
   {return((m_pShm!=NULL) ? m_pShm->nTDIChannels : 0);}
   int GetNumTDO() const                                 // # digital outputs available on event timer device 
   {return((m_pShm!=NULL) ? m_pShm->nTDOChannels : 0);}


//===================================================================================================================== 
// DIAGNOSTICS (DEBUG release only)  
//===================================================================================================================== 
public: 
#ifdef _DEBUG 
   void Dump( CDumpContext& dc ) const;                  // standard diagnostic support 
   void AssertValid() const; 
#endif


//===================================================================================================================== 
// IMPLEMENTATION
//===================================================================================================================== 
protected:
   BOOL Open();                                          // prepare IPC and start MAESTRODRIVER in idle mode
   VOID Close( const BOOL bGraceful=TRUE );              // shut down driver and clean up 
   BOOL IsAlive() const;                                       // is MAESTRODRIVER loaded and still running in RTX space?

   VOID InitIPC();                                       // initialize IPC shared memory object to startup state (idle) 

   VOID SetCurrentDateStamp();                           // update date stamp stored in IPC for use by MAESTRODRIVER

};

#endif   // !defined(CXRUNTIME_H__INCLUDED_)
